"""Initial migration

Revision ID: 0b53c747049a
Revises: 
Create Date: 2025-04-19 00:59:56.244203

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


# revision identifiers, used by Alembic.
revision: str = '0b53c747049a'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    
    # Enable PostgreSQL extensions
    op.execute('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"')
    op.execute('CREATE EXTENSION IF NOT EXISTS pg_trgm')
    op.execute('CREATE EXTENSION IF NOT EXISTS btree_gin')
    
    # Create custom enum type
    memory_state_enum = postgresql.ENUM('active', 'paused', 'archived', 'deleted', name='memory_state_enum')
    memory_state_enum.create(op.get_bind())
    
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('access_controls',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('subject_type', sa.String(), nullable=False),
        sa.Column('subject_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('object_type', sa.String(), nullable=False),
        sa.Column('object_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('effect', sa.String(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("subject_type IN ('user', 'app', 'system')", name='check_subject_type'),
        sa.CheckConstraint("object_type IN ('memory', 'category', 'app', 'user')", name='check_object_type'),
        sa.CheckConstraint("effect IN ('allow', 'deny')", name='check_effect')
    )
    op.create_index('idx_access_object', 'access_controls', ['object_type', 'object_id'], unique=False)
    op.create_index('idx_access_subject', 'access_controls', ['subject_type', 'subject_id'], unique=False)
    op.create_index('idx_access_subject_object', 'access_controls', ['subject_type', 'subject_id', 'object_type', 'object_id'], unique=False)
    op.create_index(op.f('ix_access_controls_created_at'), 'access_controls', ['created_at'], unique=False)
    op.create_index(op.f('ix_access_controls_effect'), 'access_controls', ['effect'], unique=False)
    op.create_index(op.f('ix_access_controls_object_id'), 'access_controls', ['object_id'], unique=False)
    op.create_index(op.f('ix_access_controls_object_type'), 'access_controls', ['object_type'], unique=False)
    op.create_index(op.f('ix_access_controls_subject_id'), 'access_controls', ['subject_id'], unique=False)
    op.create_index(op.f('ix_access_controls_subject_type'), 'access_controls', ['subject_type'], unique=False)

    op.create_table('archive_policies',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('criteria_type', sa.String(), nullable=False),
        sa.Column('criteria_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('days_to_archive', sa.Integer(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("criteria_type IN ('user', 'app', 'category', 'global')", name='check_criteria_type'),
        sa.CheckConstraint('days_to_archive > 0', name='check_positive_days')
    )
    op.create_index('idx_policy_criteria', 'archive_policies', ['criteria_type', 'criteria_id'], unique=False)
    op.create_index(op.f('ix_archive_policies_created_at'), 'archive_policies', ['created_at'], unique=False)
    op.create_index(op.f('ix_archive_policies_criteria_id'), 'archive_policies', ['criteria_id'], unique=False)
    op.create_index(op.f('ix_archive_policies_criteria_type'), 'archive_policies', ['criteria_type'], unique=False)

    op.create_table('categories',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("name != ''", name='check_category_name_not_empty')
    )
    op.create_index(op.f('ix_categories_created_at'), 'categories', ['created_at'], unique=False)
    op.create_index(op.f('ix_categories_name'), 'categories', ['name'], unique=True)

    op.create_table('configs',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('key', sa.String(255), nullable=False),
        sa.Column('value', sa.JSON(), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("key != ''", name='check_config_key_not_empty')
    )
    op.create_index(op.f('ix_configs_key'), 'configs', ['key'], unique=True)

    op.create_table('users',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('user_id', sa.String(255), nullable=False),
        sa.Column('name', sa.String(255), nullable=True),
        sa.Column('email', sa.String(255), nullable=True),
        sa.Column('metadata', sa.JSON(), server_default='{}', nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("user_id != ''", name='check_user_id_not_empty'),
        sa.CheckConstraint("email IS NULL OR email ~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'", name='check_valid_email')
    )
    op.create_index(op.f('ix_users_created_at'), 'users', ['created_at'], unique=False)
    op.create_index(op.f('ix_users_email'), 'users', ['email'], unique=True)
    op.create_index(op.f('ix_users_name'), 'users', ['name'], unique=False)
    op.create_index(op.f('ix_users_user_id'), 'users', ['user_id'], unique=True)

    op.create_table('apps',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('owner_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('name', sa.String(255), nullable=False),
        sa.Column('description', sa.Text(), nullable=True),
        sa.Column('metadata', sa.JSON(), server_default='{}', nullable=False),
        sa.Column('is_active', sa.Boolean(), server_default='true', nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.ForeignKeyConstraint(['owner_id'], ['users.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('owner_id', 'name', name='idx_app_owner_name'),
        sa.CheckConstraint("name != ''", name='check_app_name_not_empty')
    )
    op.create_index(op.f('ix_apps_created_at'), 'apps', ['created_at'], unique=False)
    op.create_index(op.f('ix_apps_is_active'), 'apps', ['is_active'], unique=False)
    op.create_index(op.f('ix_apps_name'), 'apps', ['name'], unique=False)
    op.create_index(op.f('ix_apps_owner_id'), 'apps', ['owner_id'], unique=False)

    op.create_table('memories',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('user_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('app_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('content', sa.Text(), nullable=False),
        sa.Column('vector', sa.Text(), nullable=True),
        sa.Column('metadata', sa.JSON(), server_default='{}', nullable=False),
        sa.Column('state', memory_state_enum, server_default='active', nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('archived_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('deleted_at', sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(['app_id'], ['apps.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("content != ''", name='check_content_not_empty'),
        sa.CheckConstraint("(state = 'archived' AND archived_at IS NOT NULL) OR (state != 'archived')", name='check_archived_state'),
        sa.CheckConstraint("(state = 'deleted' AND deleted_at IS NOT NULL) OR (state != 'deleted')", name='check_deleted_state')
    )
    op.create_index('idx_memory_app_state', 'memories', ['app_id', 'state'], unique=False)
    op.create_index('idx_memory_user_app', 'memories', ['user_id', 'app_id'], unique=False)
    op.create_index('idx_memory_user_state', 'memories', ['user_id', 'state'], unique=False)
    op.create_index('idx_memory_created_at', 'memories', ['created_at'], unique=False)
    op.create_index('idx_memory_content_search', 'memories', ['content'], postgresql_using='gin', postgresql_ops={'content': 'gin_trgm_ops'})
    op.create_index(op.f('ix_memories_app_id'), 'memories', ['app_id'], unique=False)
    op.create_index(op.f('ix_memories_archived_at'), 'memories', ['archived_at'], unique=False)
    op.create_index(op.f('ix_memories_created_at'), 'memories', ['created_at'], unique=False)
    op.create_index(op.f('ix_memories_deleted_at'), 'memories', ['deleted_at'], unique=False)
    op.create_index(op.f('ix_memories_state'), 'memories', ['state'], unique=False)
    op.create_index(op.f('ix_memories_user_id'), 'memories', ['user_id'], unique=False)

    op.create_table('memory_access_logs',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('memory_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('app_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('user_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('accessed_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('access_type', sa.String(50), nullable=False),
        sa.Column('ip_address', sa.String(45), nullable=True),  # IPv6 compatible
        sa.Column('user_agent', sa.Text(), nullable=True),
        sa.Column('metadata', sa.JSON(), server_default='{}', nullable=False),
        sa.ForeignKeyConstraint(['app_id'], ['apps.id'], ondelete='SET NULL'),
        sa.ForeignKeyConstraint(['memory_id'], ['memories.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['user_id'], ['users.id'], ondelete='SET NULL'),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint("access_type IN ('read', 'write', 'update', 'delete', 'search')", name='check_access_type')
    )
    op.create_index('idx_access_app_time', 'memory_access_logs', ['app_id', 'accessed_at'], unique=False)
    op.create_index('idx_access_memory_time', 'memory_access_logs', ['memory_id', 'accessed_at'], unique=False)
    op.create_index('idx_access_user_time', 'memory_access_logs', ['user_id', 'accessed_at'], unique=False)
    op.create_index('idx_access_type_time', 'memory_access_logs', ['access_type', 'accessed_at'], unique=False)
    op.create_index(op.f('ix_memory_access_logs_access_type'), 'memory_access_logs', ['access_type'], unique=False)
    op.create_index(op.f('ix_memory_access_logs_accessed_at'), 'memory_access_logs', ['accessed_at'], unique=False)
    op.create_index(op.f('ix_memory_access_logs_app_id'), 'memory_access_logs', ['app_id'], unique=False)
    op.create_index(op.f('ix_memory_access_logs_memory_id'), 'memory_access_logs', ['memory_id'], unique=False)
    op.create_index(op.f('ix_memory_access_logs_user_id'), 'memory_access_logs', ['user_id'], unique=False)

    op.create_table('memory_categories',
        sa.Column('memory_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('category_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.ForeignKeyConstraint(['category_id'], ['categories.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['memory_id'], ['memories.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('memory_id', 'category_id')
    )
    op.create_index('idx_memory_category', 'memory_categories', ['memory_id', 'category_id'], unique=False)
    op.create_index(op.f('ix_memory_categories_category_id'), 'memory_categories', ['category_id'], unique=False)
    op.create_index(op.f('ix_memory_categories_memory_id'), 'memory_categories', ['memory_id'], unique=False)

    op.create_table('memory_status_history',
        sa.Column('id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('memory_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('changed_by', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('old_state', memory_state_enum, nullable=False),
        sa.Column('new_state', memory_state_enum, nullable=False),
        sa.Column('changed_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=False),
        sa.Column('reason', sa.Text(), nullable=True),
        sa.ForeignKeyConstraint(['changed_by'], ['users.id'], ondelete='SET NULL'),
        sa.ForeignKeyConstraint(['memory_id'], ['memories.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('id'),
        sa.CheckConstraint('old_state != new_state', name='check_state_change')
    )
    op.create_index('idx_history_memory_state', 'memory_status_history', ['memory_id', 'new_state'], unique=False)
    op.create_index('idx_history_user_time', 'memory_status_history', ['changed_by', 'changed_at'], unique=False)
    op.create_index('idx_history_changed_at', 'memory_status_history', ['changed_at'], unique=False)
    op.create_index(op.f('ix_memory_status_history_changed_at'), 'memory_status_history', ['changed_at'], unique=False)
    op.create_index(op.f('ix_memory_status_history_changed_by'), 'memory_status_history', ['changed_by'], unique=False)
    op.create_index(op.f('ix_memory_status_history_memory_id'), 'memory_status_history', ['memory_id'], unique=False)
    op.create_index(op.f('ix_memory_status_history_new_state'), 'memory_status_history', ['new_state'], unique=False)
    op.create_index(op.f('ix_memory_status_history_old_state'), 'memory_status_history', ['old_state'], unique=False)

    # Create triggers for automatic updated_at timestamps
    op.execute("""
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
        NEW.updated_at = CURRENT_TIMESTAMP;
        RETURN NEW;
    END;
    $$ language 'plpgsql';
    """)

    # Apply triggers to tables with updated_at columns
    for table in ['users', 'apps', 'memories', 'categories', 'configs']:
        op.execute(f"""
        CREATE TRIGGER update_{table}_updated_at 
        BEFORE UPDATE ON {table} 
        FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
        """)

    # Create a function for memory state history logging
    op.execute("""
    CREATE OR REPLACE FUNCTION log_memory_state_change()
    RETURNS TRIGGER AS $$
    BEGIN
        IF OLD.state != NEW.state THEN
            INSERT INTO memory_status_history (memory_id, old_state, new_state, changed_at)
            VALUES (NEW.id, OLD.state, NEW.state, CURRENT_TIMESTAMP);
        END IF;
        RETURN NEW;
    END;
    $$ language 'plpgsql';
    """)

    # Apply trigger for memory state changes
    op.execute("""
    CREATE TRIGGER log_memory_state_change_trigger
    AFTER UPDATE ON memories
    FOR EACH ROW EXECUTE FUNCTION log_memory_state_change();
    """)

    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    
    # Drop triggers first
    trigger_tables = ['users', 'apps', 'memories', 'categories', 'configs']
    for table in trigger_tables:
        op.execute(f"DROP TRIGGER IF EXISTS update_{table}_updated_at ON {table}")
    
    op.execute("DROP TRIGGER IF EXISTS log_memory_state_change_trigger ON memories")
    
    # Drop functions
    op.execute("DROP FUNCTION IF EXISTS update_updated_at_column()")
    op.execute("DROP FUNCTION IF EXISTS log_memory_state_change()")
    
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_memory_status_history_old_state'), table_name='memory_status_history')
    op.drop_index(op.f('ix_memory_status_history_new_state'), table_name='memory_status_history')
    op.drop_index(op.f('ix_memory_status_history_memory_id'), table_name='memory_status_history')
    op.drop_index(op.f('ix_memory_status_history_changed_by'), table_name='memory_status_history')
    op.drop_index(op.f('ix_memory_status_history_changed_at'), table_name='memory_status_history')
    op.drop_index('idx_history_changed_at', table_name='memory_status_history')
    op.drop_index('idx_history_user_time', table_name='memory_status_history')
    op.drop_index('idx_history_memory_state', table_name='memory_status_history')
    op.drop_table('memory_status_history')
    
    op.drop_index(op.f('ix_memory_categories_memory_id'), table_name='memory_categories')
    op.drop_index(op.f('ix_memory_categories_category_id'), table_name='memory_categories')
    op.drop_index('idx_memory_category', table_name='memory_categories')
    op.drop_table('memory_categories')
    
    op.drop_index(op.f('ix_memory_access_logs_user_id'), table_name='memory_access_logs')
    op.drop_index(op.f('ix_memory_access_logs_memory_id'), table_name='memory_access_logs')
    op.drop_index(op.f('ix_memory_access_logs_app_id'), table_name='memory_access_logs')
    op.drop_index(op.f('ix_memory_access_logs_accessed_at'), table_name='memory_access_logs')
    op.drop_index(op.f('ix_memory_access_logs_access_type'), table_name='memory_access_logs')
    op.drop_index('idx_access_type_time', table_name='memory_access_logs')
    op.drop_index('idx_access_user_time', table_name='memory_access_logs')
    op.drop_index('idx_access_memory_time', table_name='memory_access_logs')
    op.drop_index('idx_access_app_time', table_name='memory_access_logs')
    op.drop_table('memory_access_logs')
    
    op.drop_index(op.f('ix_memories_user_id'), table_name='memories')
    op.drop_index(op.f('ix_memories_state'), table_name='memories')
    op.drop_index(op.f('ix_memories_deleted_at'), table_name='memories')
    op.drop_index(op.f('ix_memories_created_at'), table_name='memories')
    op.drop_index(op.f('ix_memories_archived_at'), table_name='memories')
    op.drop_index(op.f('ix_memories_app_id'), table_name='memories')
    op.drop_index('idx_memory_content_search', table_name='memories')
    op.drop_index('idx_memory_created_at', table_name='memories')
    op.drop_index('idx_memory_user_state', table_name='memories')
    op.drop_index('idx_memory_user_app', table_name='memories')
    op.drop_index('idx_memory_app_state', table_name='memories')
    op.drop_table('memories')
    
    op.drop_index(op.f('ix_apps_owner_id'), table_name='apps')
    op.drop_index(op.f('ix_apps_name'), table_name='apps')
    op.drop_index(op.f('ix_apps_is_active'), table_name='apps')
    op.drop_index(op.f('ix_apps_created_at'), table_name='apps')
    op.drop_table('apps')
    
    op.drop_index(op.f('ix_users_user_id'), table_name='users')
    op.drop_index(op.f('ix_users_name'), table_name='users')
    op.drop_index(op.f('ix_users_email'), table_name='users')
    op.drop_index(op.f('ix_users_created_at'), table_name='users')
    op.drop_table('users')
    
    op.drop_index(op.f('ix_configs_key'), table_name='configs')
    op.drop_table('configs')
    
    op.drop_index(op.f('ix_categories_name'), table_name='categories')
    op.drop_index(op.f('ix_categories_created_at'), table_name='categories')
    op.drop_table('categories')
    
    op.drop_index(op.f('ix_archive_policies_criteria_type'), table_name='archive_policies')
    op.drop_index(op.f('ix_archive_policies_criteria_id'), table_name='archive_policies')
    op.drop_index(op.f('ix_archive_policies_created_at'), table_name='archive_policies')
    op.drop_index('idx_policy_criteria', table_name='archive_policies')
    op.drop_table('archive_policies')
    
    op.drop_index(op.f('ix_access_controls_subject_type'), table_name='access_controls')
    op.drop_index(op.f('ix_access_controls_subject_id'), table_name='access_controls')
    op.drop_index(op.f('ix_access_controls_object_type'), table_name='access_controls')
    op.drop_index(op.f('ix_access_controls_object_id'), table_name='access_controls')
    op.drop_index(op.f('ix_access_controls_effect'), table_name='access_controls')
    op.drop_index(op.f('ix_access_controls_created_at'), table_name='access_controls')
    op.drop_index('idx_access_subject_object', table_name='access_controls')
    op.drop_index('idx_access_subject', table_name='access_controls')
    op.drop_index('idx_access_object', table_name='access_controls')
    op.drop_table('access_controls')
    
    # Drop enum type
    memory_state_enum = postgresql.ENUM('active', 'paused', 'archived', 'deleted', name='memory_state_enum')
    memory_state_enum.drop(op.get_bind())
    
    # ### end Alembic commands ###
